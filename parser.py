# parser.py - The main parser file

# Import lexer function
from lexer import simple_lexer

# Switch to toggle printing of production rules
printSwitch = True
tokens = []  # List of tokens generated by the lexer
current_token = None  # Holds the current token for parsing
index = 0  # Keeps track of the current token index

# Lexer function (calls the lexer and updates the current token)
def lexer():
    global current_token, index
    if index < len(tokens):
        current_token = tokens[index]
        index += 1
    else:
        current_token = None  # End of input

# Error handling function
def error(expected):
    print(f"Syntax error: expected {expected}, found {current_token}")
    exit(1)

# Function to parse E -> T E'
def E():
    if printSwitch:
        print("E -> T E'")
    T()
    E_prime()

# Function to parse E' -> +TE' | -TE' | ε
def E_prime():
    if printSwitch:
        print("E' -> + T E' | - T E' | ε")
    if current_token == "+":
        lexer()  # Consume '+'
        T()
        E_prime()
    elif current_token == "-":
        lexer()  # Consume '-'
        T()
        E_prime()
    # E' -> ε (do nothing for epsilon)

# Function to parse T -> id
def T():
    if printSwitch:
        print("T -> id")
    if current_token == "id":
        lexer()  # Consume 'id'
    else:
        error("id")

# New function to handle assignment statements: <Assign> -> id = E;
def Assign():
    if printSwitch:
        print("Assign -> id = Expression ;")
    lexer()  # Consume 'id'
    
    if current_token == "=":
        lexer()  # Consume '='
        E()  # Parse the expression
    
        if current_token == ";":
            lexer()  # Consume ';'
        else:
            error("; expected")
    else:
        error("= expected")

# New function to handle expression statements: <ExpressionStatement> -> E ;
def ExpressionStatement():
    E()  # Parse the expression
    if current_token == ";":
        lexer()  # Consume ';'
    else:
        error("; expected")

# Main function to determine if we are parsing an assignment or an expression
def Statement():
    if current_token == "id":
        # Peek ahead to see if it's an assignment or expression
        if tokens[index] == "=":  # Assignment case
            Assign()
        else:  # Expression case
            ExpressionStatement()
    else:
        error("id expected")

# Main parser driver
def parse(input_tokens):
    global tokens, index, current_token
    tokens = input_tokens
    index = 0
    lexer()  # Initialize the first token
    Statement()  # Start parsing from the statement (assign or expression)
    if current_token is not None:
        error("End of input expected")

